# 图像分割

## 10.1 基础知识

图像分割通常基于灰度的**不连续性**和**相似性**

图像的空间域完全分割应满足：
1. $\bigcup_{i=1}^n R_i = R$
2. $R_i, i=1,2,3,...,n$ 是连通集
3. $i \ne j \implies R_i \cap R_j = \varnothing$
4. $\mathcal{Q}(R_i) = \mathrm{TRUE}, i=1,2,3,...,n$
5. 对于任何邻接区域 $R_i$ 和 $R_j$，$\mathcal{Q}(R_i \cup R_j) = \mathrm{FALSE}$

其中 $\mathcal{Q}$ 为用户定义的谓词

## 10.2 点、线、边缘检测

实现方法基于灰度的局部急剧变化(不连续性)

### 10.2.2 孤立点检测

可使用拉普拉斯核对图像卷积，然后使用以下函数进行阈值处理，$Z$ 对应点处代表卷积结果
$$
\tag{10.15} g(x,y) = \begin{cases}
    1, &\quad |Z(x,y)| > T \\
    0, &\quad 其他
\end{cases}
$$

### 10.2.3 线检测

同样使用拉普拉斯核卷积并进行阈值处理

如果使用非各向同性核，则可检测特定方向上的线

### 10.2.4 边缘模型

* 台阶模型
* 斜坡模型
* 屋顶边缘模型

一阶导数可用于确定点是否在边缘上，二阶导数可用于确定一个边缘像素位于边缘的暗侧还是亮侧

导数对噪声很敏感，**微弱的可见噪声会严重影响边缘检测所用到的两个关键导数**

### 10.2.5 基本边缘检测

可使用 Sobel 算子检测横向和竖向梯度，也可使用 Kirsch 罗盘核检测8个方向

为了避免精细细节造成的噪声影响，可以在检测前进行平滑和/或阈值处理

### 10.2.6 更先进的边缘检测技术

#### 1. Marr-Hildreth 边缘检测子

是一个微分算子，且应可以调整到任意大小，基于高斯核和拉普拉斯核
$$
\tag{10.29} \triangledown^2 G(x,y) = K (\frac{x^2 + y^2 - 2 \sigma^2}{\sigma^4}) e^{- \frac{x^2 + y^2}{2 \sigma^2}}
$$
称为**高斯拉普拉斯(LoG)函数**

> 一个 $5 \times 5$ 的 Marr-Hildreth 近似核为
> $$
> \begin{bmatrix}
>     0 &  0 & -1 &  0 &  0 \\
>     0 & -1 & -2 & -1 &  0 \\
>    -1 & -2 & 16 & -2 & -1 \\
>     0 & -1 & -2 & -1 &  0 \\
>     0 &  0 & -1 &  0 &  0 \\
> \end{bmatrix}
> $$

Marr-Hildreth 算法如下
$$
\tag{10.30} g(x,y) = [\triangledown^2 G(x,y)] \star f(x,y) = \triangledown^2 [G(x,y) \star f(x,y)]
$$
然后寻找 $g$ 中的过零点来确定 $f$ 中边缘的位置

也可使用 **高斯差分(DoG)** 来近似 $(10.29)$
$$
\tag{10.32} \gdef\pow#1{{-\frac{x^2+y^2}{2 \sigma_{#1}^2}}} D_G(x,y) = \frac{1}{2 \pi \sigma_1^2} e^\pow{1} - \frac{1}{2 \pi \sigma_2^2} e^\pow{2}
$$
其中 $\sigma_1 > \sigma_2$，使用 $\frac{\sigma_1}{\sigma_2} = 1.6$ 的比例可为 LoG 函数提供一个更加接近的工程近似，其 $\sigma$ 值满足
$$
\tag{10.33} \sigma^2 = \frac{\sigma_1^2 \sigma_2^2}{\sigma_1^2 - \sigma_2^2} \ln [\frac{\sigma_1^2}{\sigma_2^2}]
$$

因为高斯核是可分离的，因此 LoG 和 DoG 滤波运算都可以用一维卷积实现

#### 2. 坎尼边缘检测子

1. 使用高斯核平滑图像
2. 计算梯度的幅度和角度
3. 对梯度幅度图像应用非极大值抑制
4. 使用双阈值处理和连通性分析，检测与连接边缘

#### 边缘检测算法小结

| 算法 | 识别效果 | 运行效率 |
| ---- | ------ | ------- |
| 梯度 + 阈值处理 | 差 | 快 |
| Marr-Hildreth | 中 | 中 |
| 坎尼算法       | 好 | 慢 |

### 10.2.7 连接边缘点

#### 1. 局部处理

适用于**已知各个目标的像素**的情况

在每个*边缘像素* $(x,y)$ 的邻域 $S_{xy}$ 内分析像素特点，根据预定义准则，将相似点连起来，形成具有相似性质的一个边缘，常用准则为
1. 梯度的幅度差小于阈值
2. 梯度的角度差小于阈值

如果 $S_{xy}$ 中的点 $(s,t)$ 同时满足所有准则，则将 $(s,t)$ 连接到 $(x,y)$

上述过程的简化步骤为
1. 计算输入图像 $f(x,y)$ 的梯度幅度阵列 $M(x,y)$ 和梯度角度阵列 $\alpha(x,y)$
2. 形成以下二值图像
    $$
    g(x,y) = \begin{cases}
        1, &\quad M(x,y) > T_M 且 \alpha(x,y) \in (A - T_A, A + T_A) \\
        0, &\quad 其他
    \end{cases}
    $$
3. 扫描 $g$ 的行，并在不超过规定长度 $L$ 的每行中填充所有间隙
4. 在其他任何方向 $\theta$ 上检测间隙，将 $g$ 旋转角度 $\theta$，并应用步骤 3 中的水平扫描过程，然后将结果旋转角度 $-\theta$
    > 实践中常取 $\theta = \frac{\pi}{2}$ 来进行水平和垂直边缘连接

    > 一般来说，旋转图像的计算开销很大，若需要在多个角度上连接时，将步骤 3 和 步骤 4 合并为单个径向扫描过程更为实用

#### 2. 使用霍夫变换的全局处理

适用于**非结构化环境**中，此时已知仅为一幅边缘图，感兴趣目标的位置未知

对于点 $(x,y)$，通过其的直线 $y = ax + b$ 存在无数条，其在参数空间的直线为 $b = -xa + y$ 仅有一条

多个点在平面中共线 $\implies$ 多个点在参数空间中对应的直线共点 $(a',b')$，$a'$ 为平面中直线的**斜率**，$b'$ 为平面中直线的**截距**

当直线趋近垂直方向时，$a$ 趋近无穷大，解决这个问题的方法为使用直线的法线表示
$$
\tag{10.44} x \cos \theta + y \sin \theta = \rho
$$

霍夫变换计算上的优点是可将 $\rho \theta$ 参数空间划分为多个累加单元，认为符合阈值范围的点共线
> 该算法的时间复杂度为 $O(N)$

霍夫变换也适用于形如 $g(\boldsymbol{v},\boldsymbol{c})=0$ 的任何函数，其中 $\boldsymbol{v}$ 为坐标向量，$\boldsymbol{v}$ 为系数向量

基于霍夫变换的一种连接方式为
1. 生成一幅二值边缘图像
2. 规定 $\rho \theta$ 平面中的细分
3. 检查像素高度集中的累加器单元，选取感兴趣单元
4. 检查选中单元中像素间的关系
    > 通常通过检测像素间距离来确定连续性

## 10.3 阈值处理

### 10.3.1 基础知识

1. 噪声会缩小可选阈值范围，直至无法分割
2. 如果光照或反射不均匀，也会影响直方图波峰之间的深谷，直至无法分割

### 10.3.2 基本的全局阈值处理

可用以下迭代算法实现自动阈值处理
1. 选取一个初始阈值 $T$
2. 使用 $T$ 分割图像，产生两组像素 $G_1$，$G_2$
3. 对这两组像素求平均灰度值 $m_1$，$m_2$
4. 计算新阈值 $T = \frac{1}{2}(m_1 + m_2)$
5. 重复 $2 \sim 4$，直至新旧阈值的差小于某个预定义的 $\Delta T$

### 10.3.3 使用 Otsu 方法的最优全局阈值处理

适合用于处理模式之间**较为接近**的情况

令 $\{0,1,2,\cdots,L-1\}$ 表示一幅大小为 $M \times N$ 的图像中的 $L$ 个不同的整数灰度级，$n_i$ 表示灰度级 $i$ 的像素数，则归一化后每个灰度级有 $p_i = n_i / MN$ 个分量

选定阈值 $T(k) = k, 0 < k < L-1$，使用其将图像分为 $c_1$，$c_2$ 两类像素，其中 $c_1$ 灰度值处于区间 $[0,k]$，$c_2$ 灰度值处于区间 $[k+1,L-1]$，则像素被分配给 $c_1$ 的概率为
$$
\tag{10.49} P_1(k) = \sum_{i=0}^k p_i
$$
像素被分配给 $c_2$ 的概率为 $P_2(k) = 1 - P_1(k)$

$c_1$中像素平均灰度为
$$
\tag{10.51} m_1(k) = \frac{1}{P_1(k)} \sum_{i=0}^k i p_i
$$

高达 $k$ 级的平均灰度为
$$
\tag{10.53} m(k) = \sum_{i=0}^k i p_i
$$
整个图像的平均灰度为
$$
\tag{10.54} m_G = \sum_{i=0}^{L-1} i p_i
$$

定义归一化、无量纲的测度
$$
\tag{10.57} \eta = \frac{\sigma_B^2}{\sigma_G^2}
$$
> $\eta$ 可代表阈值化处理的精度，通常 $0 \le \eta \le 1$

$\sigma_G^2$ 为全局方差
$$
\tag{10.58} \sigma_G^2 = \sum_{i=0}^{L-1} (i - m_G)^2 p_i
$$
$\sigma_B^2$ 为类间方差
$$
\tag{10.59-60} \sigma_B^2 = P_1 (m_1 - m_G)^2 + P_2 (m_2 - m_G)^2 = \frac{(m_G P_1 - m)^2}{P_1(1 - P_1)}
$$
当 $\eta(k)$ 最大，即 $\sigma_B^2(k)$ 最大时，此时的 $k$ 即为最优阈值 $k^*$
$$
\tag{10.63} \sigma_B^2(k^*) = \max_{0 \le k \le L-1} \sigma_B^2(k)
$$
若存在多个 $k^*$，习惯上取这些值的平均值

### 10.3.4 使用图像平滑改进全局阈值处理

对于有噪声的图像，可以先平滑后再进行全局阈值处理，但会导致**边界失真**

如果前景区域远小于背景区域，即使平滑处理后也无法分割出目标

### 10.3.5 使用边缘改进全局阈值处理

对于输入图像 $f(x,y)$
1. 计算其梯度幅度或拉普拉斯的绝对值，作为边缘图像
2. 选取一个阈值 $T$
3. 进行阈值处理，得到二值图像 $g_T(x,y)$ 作为模板
    > 也可同时使用梯度幅度和拉普拉斯图像的绝对值，分别进行阈值处理后，进行逻辑或运算，得到模板
4. 仅使用 $g_T$ 中值为 $1$ 的位置对应的 $f$ 中的像素，计算直方图
5. 使用该直方图全局分割 $f$，例如使用 Otsu 方法

### 10.3.6 多阈值处理

Otsu 方法可扩展到任意数量的阈值，对于分割为 $K$ 个类 $c_1,c_2,\cdots,c_K$ 时，类间方差为
$$
\tag{10.66} \sigma_B^2 = \sum_{k=1}^K P_K (m_k - m_G)^2
$$
阈值为
$$
\tag{10.69} \sigma_B^2(k_1^*, k_2^*,\cdots,k_{K-1}^*) = \max_{0<k_1<k_2<\cdots<k_{K-1}<L-1} \sigma_B^2(k_1,k_2,\cdots,k_{K-1})
$$
实践中常取 $K=3$，类间方差通常是以向量表示的多变量形式

### 10.3.7 可变阈值处理

#### 1. 基于局部图像性质的可变阈值处理

对于点 $(x,y)$ 的邻域 $S_{xy}$，$m_{xy}$ 为均值，$\sigma_{xy}$ 为标准差，定义非负常数 $a$，$b$，则可变阈值为
$$
\tag{10.78} T_{xy} = a \sigma_{xy} + b m_{xy}
$$

> 当背景灰度恒定，且目标灰度恒大于或者恒小于背景时，使用 $m_G$ 取代 $m_{xy}$  往往可以得到更好结果

#### 2. 基于移动平均的可变阈值处理

令 $z_k$ 为第 $k$ 步扫描中遇到的点的灰度，该点的移动平均为
$$
\tag{10.83} m(k+1)  = \frac{1}{n} \sum_{i=k+2-n}^{k+1} z_i, \quad k \ge n-1
$$
$n$ 为用于计算的点的数目，$m(1) = z_1$，$k \ge n+1$ 时上式可简化为
$$
m(k+1) = m(k) + \frac{1}{n} (z_{k+1} - z_{k-n}), \quad k \ge n+1
$$

令 $m_{xy}$ 为 $(x,y)$ 处的移动平均，则可变阈值为 $T_{xy} = c m_{xy}$

## 10.4 使用区域增长、区域分离、聚合进行分割

### 10.4.1 区域生长

选取一些起始点作为种子，然后将具有相同预定义性质的邻域像素添加到种子上，迭代至无更多邻域像素满足预定义性质

### 10.4.2 区域分离与聚合

1. 将满足 $\mathcal{Q}(R_i)=\mathrm{FALSE}$ 的任何区域分割为4个不相交子象限区域
2. 无法进一步分割时，聚合满足 $\mathcal{Q}(R_j \cup R_k)=TRUE$ 的邻接区域
3. 无法进一步聚合时，停止操作

## 10.5 使用聚类和超像素的区域分割

### 10.5.1 使用 K-Means 聚类的区域分割

令 $\mathcal{z} = \{\boldsymbol{z}_1,\boldsymbol{z}_2,\cdots,\boldsymbol{z}_n\}$ 为向量观测值的集合，向量的每个分量表示一个像素属性，将观测集合 $Q$ 划分为 $k$ 个不相交簇，最优准则为
$$
\tag{10.85} \arg \min_C (\sum_{i=1}^k \sum_{\boldsymbol{z \in C_i}} \| \boldsymbol{z} - \boldsymbol{m}_i \|^2)
$$
$\boldsymbol{m}_i$ 是集合 $C_i$ 中样本的均值向量

然而，求这个极小值是一个 NP 困难问题，因此常使用以下局部最优算法
1. 规定一组初始均值 $\boldsymbol{m}_i, i=1,2,\cdots,k$
2. 每个样本分配给均值最接近的聚类集合
    $$
    \boldsymbol{z}_q \rarr C_i \quad 如果 \| \boldsymbol{z}_q - \boldsymbol{m}_i \|^2 < \| \boldsymbol{z}_q - \boldsymbol{m}_j \|^2
    $$
3. 更新聚类中心
    $$
    \boldsymbol{m}_i = \frac{1}{|C_i|} \sum_{\boldsymbol{z} \in C_i} \boldsymbol{z}, \quad i=1,2,\cdots,k
    $$
    $|C_i|$ 表示簇 $C_i$ 中的样本数
4. 迭代步骤 $2 \sim 3$ ，直至残差 $E$，即当前步骤和前几个步骤中平均向量之差的欧几里得范数，小于规定阈值

### 10.5.2 使用超像素的区域分割

超像素是由多个像素组合成的区域，使用超像素有助于**提升运算性能**

#### 1. SLIC 超像素算法

**简单线性迭代聚类(SLIC)** 是对 K-Means 的一种改进，通常用于处理包含 3 个颜色分量和 2 个坐标分量的 5 维向量，可使用以下算法实现
1. 以规则网格步长 $s$ 对图像取样，计算初始超像素簇中心
    $$
    \boldsymbol{m}_i = [r_i, g_i, b_i, x_i, y_i]^T, i=1,2,\cdots,n_{sp}
    $$
    $n_{sp}$ 为所需超像素数量

    将簇中心移至 $3 \times 3$ 邻域中的最小梯度位置，对于图像中每个像素位置 $p$，设置标签 $L(p)=-1$ 和距离 $d(p)=\infin$
2. 对于每个簇中心 $\boldsymbol{m}_i$，在其 $2s \times 2s$ 邻域中，计算 $m_i$ 与每个像素 $p$ 之间的距离 $D_i(p)$，若 $D_i < d(p)$ 则令 $d(p) = D_i$，$L(p)=i$
3. 更新簇中心
    $$
    \boldsymbol{m}_i = \frac{1}{|C_i|} \sum_{\boldsymbol{z} \in C_i} \boldsymbol{z}
    $$
4. 计算残差 $E$，若小于阈值，则进入步骤 $5$，否则返回步骤 $2$
5. 将每个区域 $C_i$ 中的超像素替换为其平均值 $\boldsymbol{m}_i$

#### 2. 规定距离测度

应将颜色距离和空间距离归一化使用

实践中常近似为使用规定常数 $c$ 进行加权
$$
\tag{10.91} D = \sqrt{{d_c}^2 + (d_s / s)^2 c^2}
$$
当 $c$ 很大时，空间接近性更重要，较小时，对图像边界有更强附着性，但大小和形状更不规则

## 10.6 使用图割分割区域

### 10.6.1 作为图的图像

将图像抽象为**加权无向图**，有 2 个关键问题
* 如何关联图与图像
* 如何选取切割方式，从而分割前景和背景像素

### 10.6.2 最小图割

**最大流最小割定理**：流网络中，从源点到汇点的最大流量等于最小割

若删除最小割，则会断开源点与汇点
$$
\tag{10.97} cut(A,B) = \sum_{u \in A, v \in B} w(u,v)
$$

为避免错误的分组，可重新定义切割概念，例如使用分离测度的归一化切割
$$
\tag{10.98} Ncut(A,B) = \frac{cut(A,B)}{assoc(A,V)} + \frac{cut(A,B)}{assoc(B,V)}
$$
$$
\tag{10.99} assoc(A,V) = \sum_{u \in A, z \in V} w(u,z)
$$

图的各个分区内的归一化关联测度定义为
$$
\tag{10.101} Nassoc(A,B) = \frac{assoc(A,A)}{assoc(A,V)} + \frac{assoc(B,B)}{assoc(B,V)} = 2 - Ncut(A,B)
$$

求解 $\min Ncut(A,B)$ 是 NP 完全问题，因此需要寻找局部最优就

### 10.6.4 图割分割算法

1. 将图像转化为加权无向图 $G = (V,E)$，其权重为节点间的相似度
2. 求解 $y\boldsymbol{D} - \boldsymbol{W})\boldsymbol{x} = \lambda \boldsymbol{D} \boldsymbol{x}$ 的具有第二小特征值的特征向量，$\boldsymbol{D}$ 为距离矩阵，$\boldsymbol{W}$ 为权重矩阵，$\boldsymbol{x}$ 为指示向量，其满足 $\boldsymbol{x}_i = 1 若节点 i 在 A 中，否则 \boldsymbol{x}_i = -1$
3. 使用具有第二小的特征值的特征向量，求解使得 $Ncut(A,B)$ 最小的分离点，将图二分
4. 若分割数量未达到规定值 $K$，检查切割稳定性以决定是否继续细分当前分区
5. 必要时，递归地重新划分已分割部分

## 10.7 使用形态学分水岭分割图像

### 10.7.1 背景知识

分水岭分割常被用于**梯度图**，而不是原图像

### 10.7.3 分水岭分割算法

令 $M_1,M_2,\cdots,M_R$ 为图像 $g(x,y)$ 的区域极小值的点集，$C(M_i)$ 为与区域极小值 $M_i$ 相关联的汇水盆地的点集， $T[n]$ 为满足 $g(s,t) < n$ 的点集

水位从 $n = \mathcal{min} +1$ 上升至 $n = \mathcal{max} +1$ ，将 $T[n]$ 中的点标记为黑色，其他点标记为白色，得到二值图像

令 $C_n(M_i)$ 表示汇水盆地中与淹没阶段 $n$ 的极小值 $M_i$ 相关联的点集，其可视为以下二值图像
$$
\tag{10.111} C_n(M_i) = C(M_i) \cap T[n]
$$

令 $B$ 表示第 $n$ 阶段被洪水淹没的汇水盆地数量，$C[n]$ 表示第 $n$ 阶段这些汇水盆地的并集
$$
\tag{10.112} C[n] = \bigcup_{i=1}^B C_n(M_i)
$$

令 $Q$ 为 $T[n]$ 中的连通分量集合，对于每个连通分量 $q \in Q[n]$
* 若 $q \cap C[n-1] = \varnothing$，将 $q$ 并入 $C[n-1]$ 形成 $C[n]$
* 若 $q$ 包含 $C[n-1]$ 的一个连通分量，将 $q$ 并入 $C[n-1]$ 形成 $C[n]$
* 若 $q$ 包含 $C[n-1]$ 的多个连通分量，则使用元素为 $1$ 的 $3 \times 3$ 结构元膨胀 $q \cap C[n-1]$ 且将膨胀限制到 $q$，构建宽度为 $1$ 像素的水坝

### 10.7.4 标记的使用

为了防止过度分割，可以使用预处理、标记

与感兴趣目标相关联的标记为**内部标记**，与背景相关联的标记为**外部标记**

## 10.8 分割中运动的使用

### 10.8.1 空间域技术

#### 1. 基本方法

在 $t_i$ 和 $t_j$ 得到的两帧图像 $f(x,y,t_i)$ 与 $f(x,y,t_j)$ 之间的变化的基本定义为
$$
\tag{10.114} d_{ij}(x,y) = \begin{cases}
    1, &\quad | f(x,y,t_i) - f(x,y,t_j) | > T \\
    0, &\quad 其他 \\
\end{cases}
$$

#### 2. 累计差值

对于帧序列，以第一张为关键帧，**累计差值图像(ADI)** 是通过将关键帧与序列中每幅后续图像进行比较形成的，每次某像素处差值超过阈值时，ADI 中对应位置计数器加 $1$

### 10.8.2 频率域技术

对于由 $k$ 幅 $M \times N$ 的数字图像组成的序列，在任何整数时刻，图像到 $x$、$y$ 轴上的加权投影之和为
$$
\tag{10.119} g_x(t, a_1) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x,y,t) e^{j 2 \pi a_1 x \Delta t}, \quad t=0,1,\cdots,K-1
$$
$$
\tag{10.120} g_y(t, a_2) = \sum_{y=0}^{N-1} \sum_{x=0}^{M-1} f(x,y,t) e^{j 2 \pi a_2 y \Delta t}, \quad t=0,1,\cdots,K-1
$$
其一维傅里叶变换为
$$
\tag{10.121} G_x(u_1,a_1) = \sum_{t=0}^{K-1} g_x(t, a_1)e^{-j 2 \pi u_1 t / K}, \quad u_1=0,1,\cdots,K-1
$$
$$
\tag{10.122} G_y(u_2,a_2) = \sum_{t=0}^{K-1} g_y(t, a_2)e^{-j 2 \pi u_2 t / K}, \quad u_2=0,1,\cdots,K-1
$$
从而可以计算出速度为
$$
\tag{10.123} u_1 = a_1 V_1
$$
$$
\tag{10.124} u_2 = a_2 V_2
$$

速度的 $x$ 分量符号可由以下算式得到
$$
\tag{10.125} S_{1x} = \frac{\mathrm{d}^2 \mathrm{Re}[g_x(t,a_1)]}{\mathrm{d}t^2} \bigg|_{t=n}
$$
$$
\tag{10.126} S_{2x} = \frac{\mathrm{d}^2 \mathrm{Im}[g_x(t,a_1)]}{\mathrm{d}t^2} \bigg|_{t=n}
$$
若 $S_{1x}$ 与 $S_{2x}$ 符号相同，则 $V_1$ 为正，反之为负
